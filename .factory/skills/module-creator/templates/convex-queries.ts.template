// Template: convex/{{moduleName}}.ts
// Replace: {{moduleName}}, {{ModuleName}}, {{fields}}

import { query, mutation } from "./_generated/server";
import { v } from "convex/values";

// Document validator
const {{moduleName}}Doc = v.object({
  _id: v.id("{{moduleName}}"),
  _creationTime: v.number(),
  name: v.string(),
  slug: v.string(),
  {{#each fields}}
  {{key}}: {{validator}},
  {{/each}}
  status: v.union(v.literal("Active"), v.literal("Inactive")),
  order: v.number(),
});

// ============ QUERIES ============

export const listAll = query({
  args: {},
  returns: v.array({{moduleName}}Doc),
  handler: async (ctx) => {
    return await ctx.db.query("{{moduleName}}").collect();
  },
});

export const getById = query({
  args: { id: v.id("{{moduleName}}") },
  returns: v.union({{moduleName}}Doc, v.null()),
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});

export const getBySlug = query({
  args: { slug: v.string() },
  returns: v.union({{moduleName}}Doc, v.null()),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("{{moduleName}}")
      .withIndex("by_slug", (q) => q.eq("slug", args.slug))
      .unique();
  },
});

export const listByStatus = query({
  args: { status: v.union(v.literal("Active"), v.literal("Inactive")) },
  returns: v.array({{moduleName}}Doc),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("{{moduleName}}")
      .withIndex("by_status", (q) => q.eq("status", args.status))
      .collect();
  },
});

// ============ MUTATIONS ============

export const create = mutation({
  args: {
    name: v.string(),
    slug: v.string(),
    {{#each fields}}
    {{key}}: {{argValidator}},
    {{/each}}
    status: v.optional(v.union(v.literal("Active"), v.literal("Inactive"))),
    order: v.optional(v.number()),
  },
  returns: v.id("{{moduleName}}"),
  handler: async (ctx, args) => {
    // Check slug uniqueness
    const existing = await ctx.db
      .query("{{moduleName}}")
      .withIndex("by_slug", (q) => q.eq("slug", args.slug))
      .unique();
    if (existing) throw new Error("Slug already exists");

    // Get next order
    const count = (await ctx.db.query("{{moduleName}}").collect()).length;

    return await ctx.db.insert("{{moduleName}}", {
      ...args,
      status: args.status ?? "Active",
      order: args.order ?? count,
    });
  },
});

export const update = mutation({
  args: {
    id: v.id("{{moduleName}}"),
    name: v.optional(v.string()),
    slug: v.optional(v.string()),
    {{#each fields}}
    {{key}}: v.optional({{validator}}),
    {{/each}}
    status: v.optional(v.union(v.literal("Active"), v.literal("Inactive"))),
    order: v.optional(v.number()),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const { id, ...updates } = args;
    const item = await ctx.db.get(id);
    if (!item) throw new Error("{{ModuleName}} not found");

    // Check slug uniqueness if changed
    if (args.slug && args.slug !== item.slug) {
      const existing = await ctx.db
        .query("{{moduleName}}")
        .withIndex("by_slug", (q) => q.eq("slug", args.slug))
        .unique();
      if (existing) throw new Error("Slug already exists");
    }

    await ctx.db.patch(id, updates);
    return null;
  },
});

export const remove = mutation({
  args: { id: v.id("{{moduleName}}") },
  returns: v.null(),
  handler: async (ctx, args) => {
    const item = await ctx.db.get(args.id);
    if (!item) throw new Error("{{ModuleName}} not found");
    await ctx.db.delete(args.id);
    return null;
  },
});

export const reorder = mutation({
  args: { items: v.array(v.object({ id: v.id("{{moduleName}}"), order: v.number() })) },
  returns: v.null(),
  handler: async (ctx, args) => {
    for (const item of args.items) {
      await ctx.db.patch(item.id, { order: item.order });
    }
    return null;
  },
});
